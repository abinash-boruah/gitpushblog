<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generic binary trees</title>
    <meta name="description" content="">
    <meta name="author" content="Hrishikesh Barman">

    <link href="/assets/main.css" rel="stylesheet">

  </head>

  <body class="">
<nav class="nav">
  <div class="nav-left"></div>
  <div class="nav-center">
  <a class="nav-item title is-5" href="/">
    geekodour's blog
  </a>
  </div>
  <span id="nav-toggle" class="nav-toggle">
  <span></span>
  <span></span>
  <span></span>
  </span>
  <div id="nav-menu" class="nav-right nav-menu">
  <a class="nav-item" href="">projects</a>
  <a class="nav-item" href="">favorites</a>
  <a class="nav-item" href="">contact</a>
  </div>
</nav>

      <div class="container">
  <div class="columns">
          <div class="column">
            <div class="section">
<div class="">
Hello, welcome to my blog
</div>
            </div>
          </div>
          <div class="column is-half">
<div class="section">
<div class="container">
<div class="content">
<h1>Generic binary trees</h1>
<p>In this short post we will use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">new class syntax</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">generators</a> to create an incredibly light-weight <a href="https://en.wikipedia.org/wiki/Binary_tree">binary tree</a> representation that can easily be extended into e.g. a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a> or a <a href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search tree (BST)</a>.</p>
<p>A binary tree node consists of a value and two children, usually referred to as <code>left</code> and <code>right</code>. To make use of classes, we can represent it as follows:</p>
<pre><code class="lang-javascript">class BinaryNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}
</code></pre>
<p>Binary tree traversal is usually done with <a href="https://en.wikipedia.org/wiki/Tree_traversal#Depth-first_search">depth-first search</a>. There are three orders of depth-first traversal: <strong>pre-order</strong>, <strong>in-order</strong> and <strong>post-order</strong>.</p>
<blockquote>
<p><strong>In-order</strong></p>
<ol>
<li>Traverse the left subtree by recursively calling the in-order function.</li>
<li>Display the data part of the root (or current node).</li>
<li>Traverse the right subtree by recursively calling the in-order function.</li>
</ol>
</blockquote>
<p><strong>In-order</strong> traversal in ES6 generator land looks something like this:</p>
<pre><code class="lang-javascript">function *traverse(node) {
  if (!node)
    return;

  yield *traverse(node.left);
  yield node.value;
  yield *traverse(node.right);
}
</code></pre>
<p>Implementing <strong>pre-order</strong> and <strong>post-order</strong> is simply a matter of moving <code>yield node.value</code> <em>before</em> (pre) or <em>after</em> (post) recursion.</p>
<p>We now know enough to start implementing our binary tree.</p>
<pre><code class="lang-javascript">class BinaryTree {
  *traverse(node) {
    if (node === undefined)
      node = this.root;
    if (!node)
      return;

    yield *this.traverse(node.left);
    yield node.value;
    yield *this.traverse(node.right);
  }
}
</code></pre>
<p>Let&#39;s create a BST by extending the <code>BinaryTree</code> class with a <code>push</code> method:</p>
<pre><code class="lang-javascript">class BST extends BinaryTree {
  push(value) {
    var node = new BinaryNode(value);
    if (!this.root) {
      this.root = node;
      return;
    }

    var current = this.root;
    while (current) {
      if (node.value &lt; current.value) {
        if (!current.left) {
          current.left = node;
          break;
        }
        current = current.left;
      } else {
        if (!current.right) {
          current.right = node;
          break;
        }
        current = current.right;
      }
    }
  }
}
</code></pre>
<p>Tree traversal with the <code>for ... of</code> syntax:</p>
<pre><code class="lang-javascript">var tree = new BST();
tree.push(8);
tree.push(3);
tree.push(10);
tree.push(1);
tree.push(6);
tree.push(14);
tree.push(4);
tree.push(7);
tree.push(13);

var out = [];
for (var value of tree.traverse())
  out.push(value);

console.log(&#39;in-order:&#39;, out.join(&#39; &#39;));
// in-order: 1 3 4 6 7 8 10 13 14
</code></pre>
<p>We can define a standard iterator (<code>[Symbol.iterator]</code>) for the <code>BinaryTree</code> class to avoid having to call the <code>traverse()</code> function:</p>
<pre><code class="lang-javascript">[Symbol.iterator]() {
  return this.traverse();
}
</code></pre>
<p>Tree traversal looks like this:</p>
<pre><code class="lang-javascript">var out = [];
for (var value of tree)
  out.push(value);

console.log(&#39;in-order:&#39;, out.join(&#39; &#39;));
// in-order: 1 3 4 6 7 8 10 13 14
</code></pre>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread operator</a> can be used to unpack iterables, so the syntax can be further simplified:</p>
<pre><code class="lang-javascript">console.log(&#39;in-order:&#39;, ...tree);
// in-order: 1 3 4 6 7 8 10 13 14
</code></pre>
<p>Let&#39;s finish off by adding a <code>getter</code> for the <code>length</code> property to our <code>BinaryTree</code> class:</p>
<pre><code class="lang-javascript">get length() {
  return [...this].length;
}
</code></pre>
<p>We can now get the length of the tree:</p>
<pre><code class="lang-javascript">console.log(tree.length);
// 9
</code></pre>

</div>
</div>
</div>
          </div>
          <div class="column">
            <div class="section">
<div class="">
Hello, welcome to my blog
</div>
            </div>
          </div>
  </div>
      </div>

      <script src="/assets/prism.js"></script>
  </body>
</html>
