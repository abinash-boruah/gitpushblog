<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ring buffers and moving averages</title>
    <meta name="description" content="">
    <meta name="author" content="Hrishikesh Barman">

    <link href="/assets/main.css" rel="stylesheet">

  </head>

  <body class="">
<nav class="nav">
  <div class="nav-left"></div>
  <div class="nav-center">
  <a class="nav-item title is-5" href="/">
    geekodour's blog
  </a>
  </div>
  <span id="nav-toggle" class="nav-toggle">
  <span></span>
  <span></span>
  <span></span>
  </span>
  <div id="nav-menu" class="nav-right nav-menu">
  <a class="nav-item" href="">projects</a>
  <a class="nav-item" href="">favorites</a>
  <a class="nav-item" href="">contact</a>
  </div>
</nav>

      <div class="container">
  <div class="columns">
          <div class="column">
            <div class="section">
<div class="">
Hello, welcome to my blog
</div>
            </div>
          </div>
          <div class="column is-half">
<div class="section">
<div class="container">
<div class="content">
<h1>Ring buffers and moving averages</h1>
<p>Long time no post, so I&#39;ll just <em>casually</em> sneak in how to create a simple <a href="https://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a> in JavaScript. As a bonus, we will use the ring buffer class to implement a <a href="https://en.wikipedia.org/wiki/Moving_average#Simple_moving_average">simple moving average</a>. </p>
<p>Let&#39;s get started by looking at the awesome visualisation from the &quot;How it works&quot; part of the Wikipedia page.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/fd/Circular_Buffer_Animation.gif" alt="24-byte ring buffer"></p>
<p>As you can see, a ring buffer is a circular form of an array. In the beginning it is empty, then you push values until you reach the end. Once it is full and you perform a push, you start overwriting the oldest data. Also notice that there are two pointers; the read pointer (or head) is following the push operations and the write pointer (or tail) is following the pop operations. That&#39;s the information we need to start implementing it!</p>
<pre><code class="lang-javascript">class RingBuffer {
  constructor(capacity) {
    this.buffer = new Array(capacity);
    this.capacity = capacity;
    this.head = this.tail = this.size = 0;
  }
}
</code></pre>
<p>Nothing special here. I chose <code>Array</code> to make it generic, but you can use anything (I think the most effective would be <code>Uint8Array</code>, or maybe <code>Buffer</code>). I also added a <code>this.size</code> to track the ring buffer&#39;s size, which will come in handy once we implement the moving average.</p>
<p>Onto the <code>push()</code> function:</p>
<pre><code class="lang-javascript">push(data) {
  var next = this.head + 1;
  if (next &gt;= this.capacity)
    next = 0;
  if (this.size &lt; this.capacity)
    this.size++;

  this.buffer[this.head] = data;
  this.head = next;
}
</code></pre>
<p>We increment the <code>head</code> pointer until we reach the capacity, then we start over again. Same with size, but once we reach the capacity we stop changing it.</p>
<p>Add the <code>pop()</code> function:</p>
<pre><code class="lang-javascript">pop() {
  var data = this.buffer[this.tail],
      next = this.tail + 1;
  if (next &gt;= this.capacity)
    next = 0;
  if (this.size &gt; 0)
    this.size--;

  this.tail = next;
  return data;
}
</code></pre>
<p>This is actually almost the same as <code>push()</code>, except we decrease the size and return data.</p>
<p>We now have a fully working ring buffer, but no way to efficiently iterate through it. Let&#39;s make use of some <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator"><code>[Symbol.iterator]</code></a> magic to add a default iterator to our class.</p>
<pre><code class="lang-javascript">*[Symbol.iterator]() {
  for (var i = 0; i &lt; this.size; i++)
    yield this.buffer[(this.tail + i) % this.capacity];
}
</code></pre>
<p>The <code>*</code> denotes a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*">generator function</a> (read more about them in <a href="http://casualjavascript.com/?6">my previous post about generic binary trees</a>).</p>
<p>Let&#39;s try it and see if it works...</p>
<pre><code class="lang-javascript">var rb = new RingBuffer(5);
rb.push(1);
rb.push(2);
rb.push(3);
rb.pop();
rb.push(4);
rb.push(5);
rb.push(6);
rb.push(7);
for (var value of rb)
  console.log(value);
</code></pre>
<p>Can you visualise the result before running the code?</p>
<p>Now that we have the ring buffer, implementing a simple moving average is trivial.</p>
<pre><code class="lang-javascript">function movingAverage(rb) {
  var sum = 0;
  for (var value of rb)
    sum += value;
  return sum / rb.size;
}
</code></pre>
<p>That&#39;s all folks. Until next time.</p>

</div>
</div>
</div>
          </div>
          <div class="column">
            <div class="section">
<div class="">
Hello, welcome to my blog
</div>
            </div>
          </div>
  </div>
      </div>

      <script src="/assets/prism.js"></script>
  </body>
</html>
