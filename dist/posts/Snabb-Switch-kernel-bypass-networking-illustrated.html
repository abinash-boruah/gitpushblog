<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snabb Switch: kernel-bypass networking illustrated</title>
    <meta name="description" content="">
    <meta name="author" content="Hrishikesh Barman">

    <link href="/assets/main.css" rel="stylesheet">

  <script>
  window.blogInfo = {
          pageType: 'post',
          postId: 13,
          comment_system: "github",
          disqus_id: "geekodour",
          firebaseEnabled: true
  };
  </script>

  </head>

  <body class="">
<nav class="nav">
  <div class="nav-left"></div>
  <div class="nav-center">
  <a class="nav-item title is-5" href="/">
    geekodour's blog
  </a>
  </div>
  <span id="nav-toggle" class="nav-toggle">
  <span></span>
  <span></span>
  <span></span>
  </span>
  <div id="nav-menu" class="nav-right nav-menu">
  <a class="nav-item" href="">projects</a>
  <a class="nav-item" href="">favorites</a>
  <a class="nav-item" href="">contact</a>
  </div>
</nav>

      <div class="container">
  <div class="columns">
          <div class="column">
            <div class="section">
<div class="">
  <ul>
  </ul>
</div>
            </div>
          </div>
          <div class="column is-half">
<div class="section">
  <div class="container">
    <div class="content">
      <h1>Snabb switch: kernel-bypass networking illustrated</h1>
      <p><a href="https://github.com/SnabbCo/snabbswitch">Snabb Switch</a> is a networking application that runs on Linux. However, it does not typically use Linux&#39;s networking functionality. Instead it negotiates with the kernel to take control of whole PCI network devices and perform I/O directly without using the kernel as a middle-man. This is <strong>kernel-bypass networking</strong>.</p>
<p>Sounds abstract? Let us illustrate what that really means.</p>
<p>We will use <code>strace</code> to review the system calls that Snabb Switch makes when it runs an application that accesses the PCI network device with address <code>0000:01:00.0</code>.</p>
<p>Here we go!</p>
<h4 id="pci-device-access">pci device access</h4>
<p>First we use sysfs to discover what kind of PCI device 0000:01:00.0 is:</p>
<pre><code>open(&quot;/sys/bus/pci/devices/0000:01:00.0/vendor&quot;, O_RDONLY) = 4
read(4, &quot;0x8086\n&quot;, 4096)               = 7
open(&quot;/sys/bus/pci/devices/0000:01:00.0/device&quot;, O_RDONLY) = 4
read(4, &quot;0x10fb\n&quot;, 4096)               = 7
</code></pre><p>Good: It&#39;s an Intel 82599 10G NIC (Vendor = 0x8086 Device = 0x10fb). We happen to have a <a href="https://github.com/SnabbCo/snabbswitch/blob/master/src/apps/intel/intel10g.lua">driver</a> for this device built into Snabb Switch.</p>
<p>We ask the kernel to please unbind this PCI device from its kernel driver so that it will be available to us:</p>
<pre><code>open(&quot;/sys/bus/pci/devices/0000:01:00.0/driver/unbind&quot;, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 5
write(5, &quot;0000:01:00.0&quot;, 12)            = 12
</code></pre><p>We ask the kernel to map the device&#39;s configuration registers into our process&#39;s virtual address space.</p>
<pre><code>open(&quot;/sys/bus/pci/devices/0000:01:00.0/resource0&quot;, O_RDWR|O_SYNC) = 5
mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 5, 0) = 0x7fcc1f63b000
</code></pre><p>Now any time we access the 128KB memory area starting at address <code>0x7fcc1f63b000</code> the memory access will automatically be implemented as a callback into the NIC. This is memory-mapped I/O (&quot;MMIO&quot;). Each 32-bit value within this memory region maps onto a configuration register in the PCI device. Intel have a big PDF file (<a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/82599-10-gbe-controller-datasheet.pdf">82599 data sheet</a>) explaining what registers exist and what their values mean. We wrote our driver by reading that document and poking the right values into the right register addresses.</p>
<p>This MMIO register access is implemented directly by the CPU and is invisible to the kernel. (We won&#39;t see any register access here in the strace log because the kernel does not even know it is happening.)</p>
<h4 id="dma-memory">dma memory</h4>
<p>Now we want a memory area in our process that the NIC can read and write packets to using Direct Memory Access (DMA). The NIC will directly read and write to the RAM that belongs to our process. This allows us to transfer packets without any involvement from the kernel.</p>
<p>Really we want three memory areas:</p>
<ul>
<li>Receive Descriptor Ring where we write the addresses of buffers where we want packets to be stored.</li>
<li>Transmit Descriptor Ring where we write the addresses of buffers that we want to be transmitted.</li>
<li>Packet memory that these addresses refer to.</li>
</ul>
<p>Here is how we set that up.</p>
<p>First we allocate a <em>huge page</em> of memory. This is a block of memory (2MB or 1GB on x86) that is physically contiguous. This is important because the NIC deals in physical addresses and the descriptor rings are too large to fit on an ordinary 4KB page. (Alternatively we could use the CPU IOMMU feature to share our virtual memory map with the PCI device but we don&#39;t consider this hardware mature enough to depend on yet.)</p>
<p>There are several ways to obtain a hugetlb page on Linux. We use the System V shared memory API.</p>
<pre><code>shmget(IPC_PRIVATE, 2097152, IPC_CREAT|SHM_HUGETLB|0600) = 7995392
shmat(7995392, 0, 0)                    = 0x7fcc1e200000
</code></pre><p>Now we have a chunk of memory in our address space. To make this suitable for DMA we need to &quot;lock&quot; this memory to its current physical address and resolve what that physical address is so that we can tell the NIC.</p>
<pre><code>mlock(0x7fcc1e200000, 2097152)          = 0
open(&quot;/proc/self/pagemap&quot;, O_RDONLY)    = 6
pread(6, &quot;\0r\366\0\0\0\0\206&quot;, 8, 274442686464) = 8
</code></pre><p>Now for a small flourish: we remap the virtual address in our process to be the same as the physical address but with some high tag bits added. This is convenient for two reasons. First, it makes it very simple and efficient to translate virtual addresses into physical addresses: just mask off the tag bits. Second, it means that when multiple Snabb Switch processes map the same DMA memory they will all map it to the same address. This means that pointers into DMA memory are valid in any Snabb Switch process, which is handy when they cooperate to process packets.</p>
<pre><code>shmat(7995392, 0x500f67200000, 0)       = 0x500f67200000
mlock(0x500f67200000, 2097152)          = 0
</code></pre><p>and..</p>
<p>That is it!</p>
<p>The real action is still to come, of course, but that is a topic for another time. We wanted to illustrate the interactions between Snabb Switch and the kernel and that is complete. The rest of the story does not involve the kernel and can&#39;t be seen with strace.</p>

    </div>
  </div>
</div>
<div class="">
  <div class="container">
          <div class="section has-text-centered is-fluid">
            <button id="signin_button" class="button is-medium is-success">Sign In to Comment!</button>
            <div id="comment_box">
              <div class="field">
              <label class="label">Your Comment</label>
              <p class="control">
                <textarea class="textarea" placeholder="Write something.."></textarea>
              </p>
              </div>
            </div>
          </div>
          <div id="comments_container"></div>
          <div id="loadmore_container" class="has-text-centered"></div>
  </div>
</div>
          </div>
          <div class="column">
            <div class="section">
<div class="">
Hello, welcome to my blog
Here we have fun
</div>
            </div>
          </div>
  </div>
      </div>

      <script src="https://www.gstatic.com/firebasejs/4.1.1/firebase.js"></script>
      <script src="/assets/prism.js"></script>
      <script src="/assets/main.js"></script>
  </body>
</html>
